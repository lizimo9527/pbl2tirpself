"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.trimKotlinErrorMessage = exports.parseUTSKotlinRuntimeFilename = exports.parseUTSKotlinRuntimeStacktrace = exports.resolveUTSKotlinFilenameByClassName = exports.parseFilenameByClassName = exports.updateUTSKotlinSourceMapManifestCache = exports.createUniXPackageRegExp = exports.normalizeAppid = exports.parseUTSKotlinStacktrace = exports.hbuilderKotlinCompileErrorFormatter = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const utils_1 = require("../utils");
const sourceMap_1 = require("../sourceMap");
const utils_2 = require("./utils");
const shared_1 = require("../shared");
function hbuilderKotlinCompileErrorFormatter(m) {
    const msgs = [];
    let isFormatted = false;
    if (m.type === 'error' || m.type === 'exception') {
        const formatted = formatKotlinError(m.message, m.code?.split('\n') || [], compileFormatters);
        isFormatted = (0, utils_2.isFormattedErrorString)(formatted);
        m.message = formatted;
    }
    let msg = m.type + ': ' + m.message;
    if (m.type === 'warning') {
        // 忽略部分警告
        if (msg.includes(`Classpath entry points to a non-existent location:`) &&
            !msg.includes('.gradle') // gradle 的警告需要输出
        ) {
            return '';
        }
        msg
            .replace(/\r\n/g, '\n')
            .split('\n')
            .forEach((m, index) => {
            // 重要：区块标识需要放到颜色值之后
            msgs.push(utils_2.COLORS.warn +
                (index === 0 ? utils_1.SPECIAL_CHARS.WARN_BLOCK : '') +
                m +
                utils_2.COLORS.warn);
        });
    }
    else if (m.type === 'error' || m.type === 'exception') {
        msg
            .replace(/\r\n/g, '\n')
            .split('\n')
            .forEach((m, index) => {
            // 重要：区块标识需要放到颜色值之后
            msgs.push(utils_2.COLORS.error +
                (index === 0 ? utils_1.SPECIAL_CHARS.ERROR_BLOCK : '') +
                m +
                utils_2.COLORS.error);
        });
    }
    else {
        msgs.push(msg);
    }
    if (m.file) {
        if (m.file.includes('?')) {
            ;
            [m.file] = m.file.split('?');
        }
        msgs.push(`at ${m.file}:${m.line}:${m.column}`);
    }
    if (m.code) {
        msgs.push(m.code);
    }
    const result = msgs.join('\n');
    if (isFormatted) {
        return result;
    }
    const formatted = (0, utils_2.parseErrorWithRules)(result, {
        language: 'kotlin',
        platform: 'app-android',
    });
    if ((0, utils_2.isFormattedErrorString)(formatted)) {
        return formatted;
    }
    return (0, utils_2.addConfusingBlock)(formatted);
}
exports.hbuilderKotlinCompileErrorFormatter = hbuilderKotlinCompileErrorFormatter;
async function parseUTSKotlinStacktrace(messages, options) {
    if (typeof messages === 'string') {
        try {
            messages = JSON.parse(messages);
        }
        catch (e) { }
    }
    const msgs = [];
    if (Array.isArray(messages) && messages.length) {
        for (const m of messages) {
            if (m.file) {
                const sourceMapFile = resolveSourceMapFile(m.file, options.sourceMapDir, options.inputDir);
                if (sourceMapFile) {
                    const originalPosition = await (0, sourceMap_1.originalPositionFor)({
                        sourceMapFile,
                        line: m.line,
                        column: m.column,
                        withSourceContent: true,
                    });
                    if (originalPosition.source) {
                        // 混编的假sourcemap，需要读取源码
                        if (sourceMapFile.endsWith('.fake.map')) {
                            if (fs_extra_1.default.existsSync(m.file)) {
                                originalPosition.sourceContent = fs_extra_1.default.readFileSync(m.file, 'utf-8');
                            }
                        }
                        m.file = originalPosition.source.split('?')[0];
                        if (originalPosition.line !== null) {
                            m.line = originalPosition.line;
                        }
                        if (originalPosition.column !== null) {
                            m.column = originalPosition.column;
                        }
                        if (originalPosition.line !== null &&
                            originalPosition.column !== null &&
                            originalPosition.sourceContent) {
                            m.code = (0, utils_2.generateCodeFrame)(originalPosition.sourceContent, {
                                line: originalPosition.line,
                                column: originalPosition.column,
                            }).replace(/\t/g, ' ');
                        }
                    }
                }
            }
            let msg = options.format(m);
            if (msg) {
                if (m.type === 'error' || m.type === 'exception') {
                    msg = msg + utils_1.SPECIAL_CHARS.ERROR_BLOCK;
                }
                else if (m.type === 'warning') {
                    msg = msg + utils_1.SPECIAL_CHARS.WARN_BLOCK;
                }
                msgs.push(msg);
            }
        }
    }
    return msgs.join('\n');
}
exports.parseUTSKotlinStacktrace = parseUTSKotlinStacktrace;
function resolveSourceMapFile(file, sourceMapDir, inputDir) {
    const sourceMapFile = path_1.default.resolve(sourceMapDir, (0, utils_1.relative)(file, inputDir) + '.map');
    if (fs_extra_1.default.existsSync(sourceMapFile)) {
        return sourceMapFile;
    }
    return (0, shared_1.normalizePath)((0, utils_1.relative)(file, inputDir)) + '.fake.map';
}
const DEFAULT_APPID = '__UNI__uniappx';
function normalizeAppid(appid) {
    return appid.replace(/_/g, '');
}
exports.normalizeAppid = normalizeAppid;
function createUniXPackageRegExp(appid) {
    return new RegExp('uni\\.' + appid + '\\.(.*)\\..*\\(*\\.kt:([0-9]+)\\)');
}
exports.createUniXPackageRegExp = createUniXPackageRegExp;
let kotlinManifest = {
    mtimeMs: 0,
    manifest: {},
};
function updateUTSKotlinSourceMapManifestCache(cacheDir) {
    const manifestFile = path_1.default.resolve(cacheDir, 'src/.manifest.json');
    try {
        const stats = fs_extra_1.default.statSync(manifestFile);
        if (stats.isFile()) {
            if (kotlinManifest.mtimeMs !== stats.mtimeMs) {
                const { files } = fs_extra_1.default.readJSONSync(manifestFile);
                if (files) {
                    const classManifest = {};
                    Object.keys(files).forEach((name) => {
                        const kotlinClass = files[name].class;
                        if (kotlinClass) {
                            classManifest[kotlinClass] = name;
                        }
                    });
                    kotlinManifest.mtimeMs = stats.mtimeMs;
                    kotlinManifest.manifest = classManifest;
                }
            }
        }
    }
    catch (e) { }
}
exports.updateUTSKotlinSourceMapManifestCache = updateUTSKotlinSourceMapManifestCache;
function parseFilenameByClassName(className) {
    return kotlinManifest.manifest[className.split('$')[0]] || 'index.kt';
}
exports.parseFilenameByClassName = parseFilenameByClassName;
function resolveUTSKotlinFilenameByClassName(className, { cacheDir }) {
    updateUTSKotlinSourceMapManifestCache(cacheDir);
    return parseFilenameByClassName(className);
}
exports.resolveUTSKotlinFilenameByClassName = resolveUTSKotlinFilenameByClassName;
function parseUTSKotlinRuntimeStacktrace(stacktrace, options) {
    const appid = normalizeAppid(options.appid || DEFAULT_APPID);
    if (!stacktrace.includes('uni.' + appid + '.')) {
        return '';
    }
    updateUTSKotlinSourceMapManifestCache(options.cacheDir);
    const re = createUniXPackageRegExp(appid);
    const res = [];
    const lines = stacktrace.split(utils_2.splitRE);
    const sourceMapDir = (0, utils_2.resolveSourceMapDirByCacheDir)(options.cacheDir);
    let changed = false;
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const codes = parseUTSKotlinRuntimeStacktraceLine(line, re, sourceMapDir);
        if (codes.length && res.length) {
            const color = options.logType
                ? utils_2.COLORS[options.logType] || ''
                : '';
            const message = resolveCausedBy(res);
            const formatted = formatKotlinError(message, codes, runtimeFormatters, options.appid);
            let isFormatted = (0, utils_2.isFormattedErrorString)(formatted);
            let error = 'error: ' + formatted;
            // const isFormatted = message !== formatted
            if (color) {
                error = color + utils_1.SPECIAL_CHARS.ERROR_BLOCK + error + color;
            }
            let errorStr = [error, ...codes].join('\n');
            if (!isFormatted) {
                errorStr = (0, utils_2.parseErrorWithRules)(errorStr, {
                    language: 'kotlin',
                    platform: 'app-android',
                });
                isFormatted = (0, utils_2.isFormattedErrorString)(errorStr);
            }
            const result = (color ? '' : utils_1.SPECIAL_CHARS.ERROR_BLOCK) +
                errorStr +
                utils_1.SPECIAL_CHARS.ERROR_BLOCK;
            return isFormatted ? result : (0, utils_2.addConfusingBlock)(result);
        }
        else {
            const newLine = parseUTSKotlinRuntimeFilename(line, re, options.cacheDir);
            if (!changed && newLine !== line) {
                changed = true;
            }
            res.push(newLine);
        }
    }
    if (changed) {
        return res.join('\n');
    }
    return '';
}
exports.parseUTSKotlinRuntimeStacktrace = parseUTSKotlinRuntimeStacktrace;
function resolveCausedBy(lines) {
    // 从最后一行开始，找到第一个Caused by:
    for (let i = lines.length - 1; i >= 0; i--) {
        if (lines[i].startsWith('Caused by: ')) {
            return lines[i].replace('Caused by: ', '');
        }
    }
    return lines[0];
}
/**
 * 将类似
 * at uni.UNI1F0998C.GenPagesIndexIndex$Companion$setup$1.invoke(index.kt:25)
 * 转换为
 * at uni.UNI1F0998C.GenPagesIndexIndex$Companion$setup$1.invoke(at /xx/xx/index.kt:25)
 * @param lineStr
 * @param re
 * @param options
 * @returns
 */
function parseUTSKotlinRuntimeFilename(lineStr, re, cacheDir) {
    const matches = lineStr.match(re);
    if (!matches) {
        return lineStr;
    }
    const [, className] = matches;
    const filename = parseFilenameByClassName(className);
    return lineStr.replace(/\(.*.kt:([0-9]+)\)/, `(at ${cacheDir
        ? (0, shared_1.normalizePath)(path_1.default.resolve(cacheDir, 'src', filename))
        : filename}:$1)`);
}
exports.parseUTSKotlinRuntimeFilename = parseUTSKotlinRuntimeFilename;
function parseUTSKotlinRuntimeStacktraceLine(lineStr, re, sourceMapDir) {
    const lines = [];
    const matches = lineStr.match(re);
    if (!matches) {
        return lines;
    }
    const [, className, line] = matches;
    const filename = parseFilenameByClassName(className);
    const sourceMapFile = (0, utils_2.resolveSourceMapFileBySourceFile)(filename, sourceMapDir);
    if (!sourceMapFile) {
        return lines;
    }
    const originalPosition = (0, sourceMap_1.originalPositionForSync)({
        sourceMapFile,
        line: parseInt(line),
        column: 0,
        withSourceContent: true,
    });
    if (originalPosition.source && originalPosition.sourceContent) {
        lines.push(`at ${originalPosition.source.split('?')[0]}:${originalPosition.line}:${originalPosition.column}`);
        if (originalPosition.line !== null && originalPosition.column !== null) {
            const { start, end } = (0, utils_2.lineColumnToStartEnd)(originalPosition.sourceContent, originalPosition.line, originalPosition.column);
            lines.push((0, utils_2.generateCodeFrame)(originalPosition.sourceContent, start, end).replace(/\t/g, ' '));
        }
    }
    return lines;
}
const TYPE_MISMATCH_RE = /Type mismatch: inferred type is (.*) but (.*) was expected/;
function normalizeType(type) {
    type = type.replace(/\b(Unit)\b/g, 'Unit \x1b[90m/* = void */\x1b[39m');
    if (type.endsWith('?')) {
        let nonOptional = type.slice(0, -1);
        if (nonOptional.startsWith('(') && nonOptional.endsWith(')')) {
            nonOptional = nonOptional.slice(1, -1);
        }
        return `${type}（可为空的${nonOptional}）`;
    }
    return type;
}
const extApiCompileErrorFormatter = {
    format(error, codes) {
        if (codes.length && error.includes(`Unresolved reference `)) {
            const api = findUniExtApi(codes.join('\n'), UNI_API_RE, '^');
            if (api) {
                return (0, utils_2.createFormattedErrorString)(`请检查 ${api} 的拼写是否正确，或确认当前 HBuilderX 版本在当前平台是否支持此 API。`);
            }
            return ``;
        }
    },
};
const extApiRuntimeErrorFormatter = {
    format(error, codes) {
        if (codes.length && error.includes('Failed resolution of: L')) {
            let isUniExtApi = error.includes('uts/sdk/modules/DCloudUni') ||
                error.includes('io/dcloud/uniapp/extapi/');
            let isUniCloudApi = !isUniExtApi && error.includes('io/dcloud/unicloud/UniCloud');
            if (isUniExtApi || isUniCloudApi) {
                let api = findUniExtApi(codes[codes.length - 1], isUniCloudApi ? UNI_CLOUD_API_RE : UNI_API_RE, '^^^^^');
                if (api) {
                    api = `api ${api}`;
                }
                else {
                    api = `您使用到的api`;
                }
                return (0, utils_2.createFormattedErrorString)(`[EXCEPTION] 当前运行的基座未包含${api}，请重新打包自定义基座再运行。`);
            }
        }
        else if (error.includes(`Unresolved reference 'uni_`)) {
            // let api = findUniExtApi(codes[codes.length - 1], UNI_API_RE)
            return ``;
        }
    },
};
function findUniExtApi(error, re, includeStr) {
    let api = '';
    // 第一步先遍历查找^^^^^的索引
    const codeFrames = error.split(utils_2.splitRE);
    const index = codeFrames.findIndex((frame) => frame.includes(includeStr));
    if (index > 0) {
        // 第二步，取前一条记录，查找uni.开头的api
        api = findApi(codeFrames[index - 1], re);
    }
    return api;
}
function trimKotlinErrorMessage(error, appid) {
    if (appid) {
        error = error.replaceAll(parseUniXAppAndroidPackage(appid) + '.', '');
    }
    let shouldTrimRenamer = true;
    const matches = error.match(TYPE_MISMATCH_RE);
    if (matches) {
        const [, inferredType, expectedType] = matches;
        // 如果是类型相同，则不进行重命名，不然会提示A不匹配A，更容易误解
        if (inferredType.replace('?', '').replace(/__[0-9]+/g, '') ===
            expectedType.replace('?', '').replace(/__[0-9]+/g, '')) {
            shouldTrimRenamer = false;
        }
    }
    if (shouldTrimRenamer) {
        error = error.replace(/__[0-9]+/g, '');
    }
    return error.replace(/io\.dcloud\.[a-zA-Z0-9_.]+\./g, '');
}
exports.trimKotlinErrorMessage = trimKotlinErrorMessage;
function parseOrigType(type1, type2) {
    if (type1.startsWith(type2)) {
        const renamedIndex = type1.replace(type2, '');
        if (/[0-9]+/.test(renamedIndex)) {
            return type2;
        }
    }
}
const typeMismatchErrorFormatter = {
    format(error, _) {
        const matches = error.match(TYPE_MISMATCH_RE);
        if (matches) {
            const [, inferredType, expectedType] = matches;
            const normalizedInferredType = normalizeType(inferredType);
            const normalizedExpectedType = normalizeType(expectedType);
            let extra = '';
            const origType = parseOrigType(normalizedInferredType, normalizedExpectedType) ||
                parseOrigType(normalizedExpectedType, normalizedInferredType);
            if (origType) {
                extra = `该错误可能是没有使用import导入${origType}引发的`;
            }
            return (0, utils_2.createFormattedErrorString)(`类型不匹配: 推断类型是${normalizedInferredType}，但预期的是${normalizedExpectedType}${extra ? `，${extra}` : ''}。`);
        }
    },
};
// error: Unresolved reference: PreLoginOptions‌
const UNRESOLVED_REFERENCE_RE = /Unresolved reference '(.*)'/;
const unresolvedApiMap = require('../../lib/kotlin/unresolved.json');
const unresolvedErrorFormatter = {
    format(error, _) {
        const matches = error.match(UNRESOLVED_REFERENCE_RE);
        if (matches) {
            const name = matches[1].trim();
            const api = unresolvedApiMap[name];
            if (api) {
                return `找不到名称"${name}"。[详情](${api.url})`;
            }
        }
    },
};
const compileFormatters = [
    typeMismatchErrorFormatter,
    extApiCompileErrorFormatter,
    unresolvedErrorFormatter,
];
const runtimeFormatters = [extApiRuntimeErrorFormatter];
const UNI_API_RE = /(uni\.\w+)/;
const UNI_CLOUD_API_RE = /(uniCloud\.\w+)/;
function findApi(msg, re) {
    const matches = msg.match(re);
    if (matches) {
        return matches[1];
    }
    return '';
}
function formatKotlinError(error, codes, formatters, appid) {
    // 替换响应式类型为标准类型，使用对象映射提高可维护性
    const typeReplacements = {
        UTSReactiveJSONObject: 'UTSJSONObject',
        UTSReactiveSet: 'Set',
        UTSReactiveMap: 'Map',
        UTSReactiveArray: 'Array',
    };
    Object.entries(typeReplacements).forEach(([reactiveType, standardType]) => {
        error = error.replace(new RegExp(`\\b${reactiveType}\\b`, 'g'), standardType);
    });
    error = trimKotlinErrorMessage(error, appid);
    for (const formatter of formatters) {
        const err = formatter.format(error, codes, appid);
        if (err) {
            return err;
        }
    }
    return error;
}
function parseUniXAppAndroidPackage(appid) {
    return 'uni.' + appid.replace(/_/g, '');
}
