"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRollupError = exports.createUniXCompiler = void 0;
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const sourceMap_1 = require("../sourceMap");
const shared_1 = require("../shared");
const utils_1 = require("../utils");
const utils_2 = require("../stacktrace/utils");
const debugTscWatcher = (0, debug_1.default)('uts:tsc:watcher');
const debugCompile = (0, debug_1.default)('uts:tsc:compile');
const UNI_APP_X_TYPE_VALIDATION = process.env.UNI_APP_X_TYPE_VALIDATION === 'true' ? true : false;
const hbxVersion = process.env.HX_Version || '';
const hxDev = hbxVersion.endsWith('-dev');
function createUniXCompiler(mode, targetLanguage, options) {
    const inputDir = (0, shared_1.normalizePath)(options.inputDir);
    const utsLibDir = path_1.default.resolve(__dirname, '../../lib');
    const pluginPath = process.env.UNI_HBUILDERX_PLUGINS
        ? process.env.UNI_HBUILDERX_PLUGINS
        : path_1.default.resolve(process.cwd(), '../');
    const hxLanguageServiceDir = path_1.default.resolve(pluginPath, 'hbuilderx-language-services');
    const tsFactory = require(path_1.default.resolve(utsLibDir, 'typescript/lib/typescript.factory.js'));
    const fileWatcher = new UTSFileWatcher({
        tscDir: inputDir,
        inputDir: process.env.UNI_INPUT_DIR,
    });
    const watchFile = (fileName, callback, pollingInterval, options) => {
        // 仅监听工程目录内的文件
        if (fileName.startsWith(inputDir)) {
            return fileWatcher.watchFile(fileName, callback, pollingInterval, options);
        }
        return {
            close() {
                /* noop */
            },
        };
    };
    const sourceMap = process.env.UNI_APP_SOURCEMAP === 'true' ||
        process.env.NODE_ENV === 'development';
    const compilerOptions = {
        mode,
        targetLanguage: targetLanguage,
        tsFactory,
        hxPluginDir: pluginPath,
        paths: options.paths,
        utsLibDir,
        hxLanguageServiceDir,
        sourceMap,
        inlineSources: sourceMap,
        watchFile,
        incremental: mode === 'development',
        transformOptions: {
            enableUTSNumber: false,
            enableNarrowType: true, // 默认开启
            enableGenericsParameterDefaults: (0, utils_1.isEnableGenericsParameterDefaults)(),
            // TODO 调整参数传递方式
            isPureSwift: options.isPureSwift,
            workers: {
                resolve: options.resolveWorkers,
                extname: targetLanguage === 'ArkTS'
                    ? '.ets'
                    : targetLanguage === 'JavaScript'
                        ? '.js'
                        : undefined,
            },
        },
        ...options,
    };
    const { UniXCompiler } = require('../../lib/uni-x/dist/compiler');
    const compiler = new UniXCompiler(compilerOptions);
    const reportDiagnostic = createReportDiagnostic(compiler, inputDir);
    // 目前触发编译的，只有addRootFile、addRootFiles、invalidate
    // 所以这里监听这些方法，并打印出诊断信息
    const oldAddRootFile = compiler.addRootFile;
    compiler.addRootFile = async function (file) {
        await oldAddRootFile.call(compiler, file);
        reportDiagnostics();
    };
    const oldAddRootFiles = compiler.addRootFiles;
    compiler.addRootFiles = async function (files) {
        await oldAddRootFiles.call(compiler, files);
        reportDiagnostics();
    };
    compiler.invalidate = async (files) => {
        let timeout = 300;
        for (const { fileName, event } of files) {
            if (fileWatcher.onWatchFileChange(fileName, event)) {
                timeout = 2000;
            }
        }
        await compiler.wait(timeout);
        reportDiagnostics();
    };
    return compiler;
    function reportDiagnostics() {
        const program = compiler.getProgram();
        if (program) {
            const syntacticDiagnostics = program.getSyntacticDiagnostics();
            syntacticDiagnostics.forEach((diagnostic) => {
                reportDiagnostic('syntactic', diagnostic);
            });
            const semanticDiagnostics = program.getSemanticDiagnostics();
            semanticDiagnostics.forEach((diagnostic) => {
                reportDiagnostic('semantic', diagnostic);
            });
        }
    }
}
exports.createUniXCompiler = createUniXCompiler;
const replacements = /(\.uts|\.uvue|\.vue|\.json)\.ts$/;
class UTSFileWatcher {
    constructor({ tscDir, inputDir }) {
        this._watchFiles = new Map();
        this._tscDir = tscDir;
        this._inputDir = inputDir;
    }
    watchFile(fileName, callback, pollingInterval, options) {
        // 此时记录的是emit出来的.tsc目录的文件
        const key = (0, shared_1.normalizePath)(path_1.default.relative(this._tscDir, fileName).replace(replacements, '$1'));
        this._watchFiles.set(key, { fileName, callback });
        return {
            close: () => {
                this._watchFiles.delete(key);
            },
        };
    }
    onWatchFileChange(fileName, event) {
        const relativeFileName = (0, shared_1.normalizePath)(path_1.default.relative(this._inputDir, fileName));
        const watcher = this._watchFiles.get(relativeFileName);
        if (watcher) {
            // Created = 0,
            // Changed = 1,
            // Deleted = 2,
            debugTscWatcher(relativeFileName, event);
            watcher.callback(watcher.fileName, event === 'update' ? 1 : event === 'delete' ? 2 : 0);
            return true;
        }
        else {
            debugTscWatcher(relativeFileName, ' not found');
        }
        return false;
    }
}
function createReportDiagnostic(compiler, inputDir) {
    const formatHost = {
        getCanonicalFileName: (path) => path,
        getCurrentDirectory: () => inputDir,
        getNewLine: () => compiler.getTypeScript().sys.newLine,
    };
    const encryptExistCache = new Map();
    return reportDiagnostic;
    function diagnosticCategoryName(d, lowerCase = true) {
        const name = compiler.getTypeScript().DiagnosticCategory[d.category];
        return lowerCase ? name.toLowerCase() : name;
    }
    function reportDiagnostic(_type, diagnostic) {
        const errorCode = UNI_APP_X_TYPE_VALIDATION
            ? [2300, 2451, 110111119, 2564, 1023]
            : [];
        const throwError = diagnostic.__throwError ||
            [
                100006,
                110111101,
                110111163,
                110111120,
                110111134,
                110111164,
                110111146,
                110111143,
                110111149,
                110111138,
                110111161,
                110111128,
                ...errorCode,
            ].includes(diagnostic.code);
        const isDebug = debugCompile.enabled;
        const isWarning = !hxDev && errorCode.includes(diagnostic.code);
        const color = isWarning ? utils_2.COLORS.warn : utils_2.COLORS.error;
        const block = isWarning
            ? utils_1.SPECIAL_CHARS.WARN_BLOCK
            : utils_1.SPECIAL_CHARS.ERROR_BLOCK;
        if (throwError) {
            const error = formatDiagnostic(diagnostic, formatHost);
            // 仅回源成功的才抛出错误，否则只打印一下
            if (error.file && error.frame) {
                const parts = error.file.replace(/\\/g, '/').split('/');
                if (parts.length > 2 && parts[0] === 'uni_modules') {
                    const pluginName = parts[1];
                    if (encryptExistCache.has(pluginName)) {
                        if (!encryptExistCache.get(pluginName)) {
                            if (!isWarning) {
                                throw createRollupError(error);
                            }
                            else {
                                printError(error, color, block);
                            }
                        }
                        return;
                    }
                    const encrypt = path_1.default.join(process.env.UNI_INPUT_DIR, 'uni_modules', pluginName, 'encrypt');
                    if (encrypt && fs_extra_1.default.existsSync(encrypt)) {
                        encryptExistCache.set(pluginName, true);
                        return;
                    }
                    else {
                        encryptExistCache.set(pluginName, false);
                    }
                }
                if (!isWarning) {
                    throw createRollupError(error);
                }
                else {
                    printError(error, color, block);
                }
            }
            else {
                if (!isWarning) {
                    throw createRollupError(error);
                }
                else {
                    printError(error, color, block);
                }
            }
        }
        if (isDebug) {
            printError(formatDiagnostic(diagnostic, formatHost), utils_2.COLORS.error, utils_1.SPECIAL_CHARS.ERROR_BLOCK);
        }
    }
    function formatDiagnostic(diagnostic, host) {
        const ts = compiler.getTypeScript();
        const errorMessage = `${diagnosticCategoryName(diagnostic)}${diagnostic.code ? ' UTS' + diagnostic.code : ''}: ${ts.flattenDiagnosticMessageText(diagnostic.messageText, host.getNewLine())}`;
        if (diagnostic.file) {
            let frame;
            let { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);
            line = line + 1;
            character = character + 1;
            let fileName = diagnostic.file.fileName;
            const sourceMapFile = fileName + '.map';
            if (fs_extra_1.default.existsSync(sourceMapFile)) {
                const pos = (0, sourceMap_1.originalPositionForSync)({
                    sourceMapFile,
                    line,
                    column: character - 1,
                    withSourceContent: true,
                });
                if (pos && pos.source) {
                    line = pos.line;
                    character = pos.column;
                    fileName = pos.source;
                    if (pos.sourceContent) {
                        frame = (0, utils_2.generateCodeFrame)(pos.sourceContent, {
                            line,
                            column: character,
                        }).replace(/\t/g, ' ');
                    }
                }
            }
            else {
                frame = (0, utils_2.generateCodeFrame)(diagnostic.file.text, {
                    line,
                    column: character,
                }).replace(/\t/g, ' ');
            }
            if (path_1.default.isAbsolute(fileName)) {
                fileName = path_1.default.relative(inputDir, fileName);
            }
            fileName = fileName.replace(/\.(uvue|vue|uts)\.ts/, '.$1');
            return {
                msg: errorMessage,
                file: fileName,
                line,
                column: character,
                frame,
            };
        }
        return {
            msg: errorMessage,
        };
    }
}
function createRollupError(error) {
    const rollupError = new Error(error.msg);
    rollupError.customPrint = () => {
        printError(error, utils_2.COLORS.error, utils_1.SPECIAL_CHARS.ERROR_BLOCK);
    };
    return rollupError;
}
exports.createRollupError = createRollupError;
function printError(error, color, block) {
    const blockContent = error.file && error.frame ? block : '';
    console.log(color + blockContent + error.msg + color);
    if (error.file) {
        console.log(`at ${error.file}:${error.line}:${error.column}`);
    }
    if (error.frame) {
        console.log(error.frame + blockContent);
    }
}
